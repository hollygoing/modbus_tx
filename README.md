1. CS1沿线上有两个远程IO模块，即两个下位机。本地的输入输出基于IO1和IO2，应该是CS1和远程IO动态匹配的。

2. 设置为皮带则主画面显示皮带控制画面。

3. 皮带1只有俩电机，输入输出点不重复即可。

   /*

   ​    定义为全局变量

   */

   ```
   struct buffer{
   
   //定义该中位机中所拥有的所有数据
   
   }
   
   buffer  ip1，ip2，ip3，ip4；//定义四个实例用于接收数据
   
   buffer  op1，op2，op3，op4；//定义四个实例用于下发数据
   ```

/*

​    读取中位机并显示过程

*/

```
QTimer{  //每隔1000ms触发一次

for（ip1 to ip4）{//轮询  向四个中位机发送读取的Modbus}

}

//串口监听并从缓冲区中读取数据

//按照顺序赋值给ip1 ip2 ip3 ip4 

//我觉得还得赋值给op1 op2 op3 op4

//前端界面根据需要取用值并显示
```

/*

​    逻辑判断过程

*/

```
//逻辑判断
press one{//按下1试图启动皮带1

if(急停输出点为0 && 跑偏输入点有信号且超出保护延时时间 && 联锁输入点有信号 && 准备就绪输入点1有信号){ //先判断启车条件
/*
按照配置进行启车预警
*/

将电机1启动的开关量设置为1

  wait 5s

  if（电机1反馈输入点有信号）{

    将电机2启动的开关量设置为1
    
    wait 5s

    if（电机2反馈输入点有信号）{
    
       皮带1的开关量置为1，代表皮带1已经启动
       
    }
    else 电机1、电机2都置为0 即立即停车
  }
  else 电机1置为0 即立即停车
}
}


if(皮带的开关量为1){
沿线无报警信号，跑偏未动作，联锁输入点有信号，准备就绪输入点1有信号
一项不符合即将 皮带1的开关量置为0 代表关停皮带1
}
```

/*

​    数据下发过程

*/

```
QTimer{  //每隔1000ms触发一次

for（op1 to op4）{//向四个中位机发送写寄存器的Modbus数据帧}

}
```



使用MODBUS RTU　协议　38400,N,8,1
1.开关量输出(1位)  
  操作命令： 0x01读取状态，0x05 或0x15写入
　地址: 00至40*8  每个远程IO板占用8个地址
2.开关量输入(1位) 
  操作命令： 0x02读取状态
　地址: 00至40*8  每个远程IO板占用8个地址
3.模拟量和计数脉冲输入(16位)
  操作命令： 0x03读取状态
　地址: 00至40*8  每个远程IO板占用8个地址
　　　　每组8寄存器定义: 00-03模拟量输入 04 计数脉冲输入
4.闭锁信息(16位)
  操作命令： 0x04读取状态
  地址:    00  设备总数量	
	01  终端电压
　02　响应事件类型
	03　响应事件位置
	04  远程IO数量
    05  闭锁按下详细位置
    10  远程IO板故障位置